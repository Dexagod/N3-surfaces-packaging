"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.n3reasoner = exports.executeBasicEyeQuery = exports.runQuery = exports.SwiplEye = exports.loadEyeImage = void 0;
const n3_1 = require("n3");
const swipl_bundle_no_data_1 = __importDefault(require("swipl-wasm/dist/swipl/swipl-bundle-no-data"));
const strToBuffer_1 = __importDefault(require("swipl-wasm/dist/strToBuffer"));
const n3Writer_temp_1 = require("./n3Writer.temp");
const eye_1 = __importDefault(require("./eye"));
const query_1 = require("./query");
function loadEyeImage(swipl) {
    return (options) => swipl({
        ...options,
        arguments: ['-q', '-x', 'eye.pvm'],
        // @ts-ignore
        preRun: (module) => module.FS.writeFile('eye.pvm', (0, strToBuffer_1.default)(eye_1.default)),
    });
}
exports.loadEyeImage = loadEyeImage;
/**
 * Creates default SWIPL image loaded with EYE
 */
function SwiplEye(options) {
    return loadEyeImage(swipl_bundle_no_data_1.default)(options);
}
exports.SwiplEye = SwiplEye;
/**
 * Execute a query over a given data file
 * @param Module A SWIPL Module
 * @param data The data for the query (in Notation3)
 * @param queryString The query (in Notation3)
 * @param options The reasoner options
 *  - output: What to output with implicit queries (default: undefined)
 * @returns The same SWIPL module
 */
function runQuery(Module, data, queryString, { output } = {}) {
    const args = ['--nope', '--quiet', 'data.nq'];
    if (queryString) {
        if (output) {
            throw new Error('Cannot use explicit output with explicit query');
        }
        Module.FS.writeFile('query.nq', queryString);
        args.push('--query', './query.nq');
    }
    else {
        switch (output) {
            case undefined:
            case 'derivations':
                args.push('--pass-only-new');
                break;
            case 'deductive_closure':
                args.push('--pass');
                break;
            case 'deductive_closure_plus_rules':
                args.push('--pass-all');
                break;
            case 'grounded_deductive_closure_plus_rules':
                args.push('--pass-all-ground');
                break;
            default:
                throw new Error(`Unknown output option: ${output}`);
        }
    }
    Module.FS.writeFile('data.nq', data);
    (0, query_1.queryOnce)(Module, 'main', args);
    return Module;
}
exports.runQuery = runQuery;
function parse(res) {
    const parser = new n3_1.Parser({ format: 'text/n3' });
    // Workaround for https://github.com/rdfjs/N3.js/issues/324
    // @ts-expect-error
    // eslint-disable-next-line no-underscore-dangle
    parser._supportsRDFStar = true;
    return parser.parse(res);
}
async function executeBasicEyeQuery(swipl, data, query, options) {
    /* eslint-enable max-len */
    const outputType = options?.outputType;
    let res = '';
    const err = [];
    const Module = await loadEyeImage(swipl)({
        print: (str) => { res += `${str}\n`; },
        printErr: (str) => { err.push(str); },
    });
    runQuery(Module, typeof data === 'string' ? data : (0, n3Writer_temp_1.write)(data), query && (typeof query === 'string' ? query : (0, n3Writer_temp_1.write)(query)), options);
    if (err.length > 0) {
        throw new Error(`Error while executing query: ${err.join('\n')}`);
    }
    return (outputType === 'quads' || (typeof data !== 'string' && outputType !== 'string'))
        ? parse(res)
        : res;
}
exports.executeBasicEyeQuery = executeBasicEyeQuery;
async function n3reasoner(data, query, options) {
    /* eslint-enable max-len */
    return executeBasicEyeQuery(options?.SWIPL || swipl_bundle_no_data_1.default, data, query, options);
}
exports.n3reasoner = n3reasoner;
