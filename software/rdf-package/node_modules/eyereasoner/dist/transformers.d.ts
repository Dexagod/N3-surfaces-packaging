/// <reference types="emscripten" />
import { Quad } from '@rdfjs/types';
import SWIPL, { type SWIPLModule } from 'swipl-wasm/dist/swipl/swipl-bundle-no-data';
export type ICoreQueryOptions = {
    output?: 'derivations' | 'deductive_closure' | 'deductive_closure_plus_rules' | 'grounded_deductive_closure_plus_rules';
};
export type Options = ICoreQueryOptions & {
    outputType?: 'string' | 'quads';
    SWIPL?: typeof SWIPL;
};
export declare function loadEyeImage(swipl: typeof SWIPL): (options?: Partial<EmscriptenModule> | undefined) => Promise<SWIPL.SWIPLModule>;
/**
 * Creates default SWIPL image loaded with EYE
 */
export declare function SwiplEye(options?: Partial<EmscriptenModule> | undefined): Promise<SWIPL.SWIPLModule>;
/**
 * Execute a query over a given data file
 * @param Module A SWIPL Module
 * @param data The data for the query (in Notation3)
 * @param queryString The query (in Notation3)
 * @param options The reasoner options
 *  - output: What to output with implicit queries (default: undefined)
 * @returns The same SWIPL module
 */
export declare function runQuery(Module: SWIPLModule, data: string, queryString?: string, { output }?: Options): SWIPLModule;
export type Data = Quad[] | string;
export type Query = Data | undefined;
/**
 * Executes a basic query using the EYE Reasoner and default build of SWIPL
 * @param data The data for the query as RDF/JS quads
 * @param query The query as RDF/JS quads
 * @param options The reasoner options
 *  - output: What to output with implicit queries (default: undefined)
 *  - outputType: The type of output, either 'string' or 'quads' (default: type of input data)
 *  - SWIPL: The SWIPL module to use (default: bundled SWIPL)
 * @returns The result of the query as RDF/JS quads
 */
export declare function executeBasicEyeQuery(swipl: typeof SWIPL, data: Data, query: Query, options: {
    outputType: 'string';
} & Options): Promise<string>;
export declare function executeBasicEyeQuery(swipl: typeof SWIPL, data: Data, query: Query, options: {
    outputType: 'quads';
} & Options): Promise<Quad[]>;
export declare function executeBasicEyeQuery(swipl: typeof SWIPL, data: Quad[], query?: Query, options?: {
    outputType?: undefined;
} & Options): Promise<Quad[]>;
export declare function executeBasicEyeQuery(swipl: typeof SWIPL, data: string, query?: Query, options?: {
    outputType?: undefined;
} & Options): Promise<string>;
export declare function executeBasicEyeQuery(swipl: typeof SWIPL, data: Data, query?: Query, options?: Options): Promise<Quad[] | string>;
/**
 * Executes a basic query using the EYE Reasoner and default build of SWIPL
 * @param swipl The base SWIPL module to use
 * @param data The data for the query as RDF/JS quads
 * @param query The query as RDF/JS quads
 * @param options The reasoner options
 *  - output: What to output with implicit queries (default: undefined)
 *  - outputType: The type of output, either 'string' or 'quads' (default: type of input data)
 * @returns The result of the query as RDF/JS quads
 */
export declare function n3reasoner(data: Data, query: Query, options: {
    outputType: 'string';
} & Options): Promise<string>;
export declare function n3reasoner(data: Data, query: Query, options: {
    outputType: 'quads';
} & Options): Promise<Quad[]>;
export declare function n3reasoner(data: Quad[], query?: Query, options?: {
    outputType?: undefined;
} & Options): Promise<Quad[]>;
export declare function n3reasoner(data: string, query?: Query, options?: {
    outputType?: undefined;
} & Options): Promise<string>;
export declare function n3reasoner(data: Data, query?: Query, options?: Options): Promise<Quad[] | string>;
